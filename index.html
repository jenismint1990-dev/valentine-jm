<script>
    const noBtn = document.getElementById('noBtn');
    const yesBtn = document.getElementById('yesBtn');
    const successPage = document.getElementById('successPage');
    const container = document.querySelector('.container');

    // ────────────────────────────────────────────────
    //  Adjustable settings
    // ────────────────────────────────────────────────
    const TRIGGER_DISTANCE = 110;     // when mouse closer than this → move
    const MAX_MOVE_PER_EVENT = 35;    // how far it jumps max per mousemove
    const RANDOM_ANGLE_JITTER = 25;   // degrees of randomness in escape direction
    const KEEP_IN_MARGIN = 60;        // keep button at least this far from screen edge

    let isRunningAway = false;

    function getSafeRandomDirectionAngle(mouseX, mouseY) {
        const rect = noBtn.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        let angle = Math.atan2(centerY - mouseY, centerX - mouseX); // radians

        // Add small random jitter so it doesn't always go perfectly opposite
        const jitter = (Math.random() - 0.5) * (RANDOM_ANGLE_JITTER * Math.PI / 180);
        angle += jitter;

        return angle;
    }

    function moveButtonAway(mouseX, mouseY) {
        const rect = noBtn.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        const dx = centerX - mouseX;
        const dy = centerY - mouseY;
        const distance = Math.hypot(dx, dy);

        if (distance >= TRIGGER_DISTANCE || distance === 0) {
            isRunningAway = false;
            return;
        }

        isRunningAway = true;

        // Decide direction & distance
        const angle = getSafeRandomDirectionAngle(mouseX, mouseY);
        let moveDist = MAX_MOVE_PER_EVENT * (1 - distance / TRIGGER_DISTANCE); // less when farther
        moveDist = Math.max(8, moveDist); // minimum kick

        let moveX = Math.cos(angle) * moveDist;
        let moveY = Math.sin(angle) * moveDist;

        // New position
        let newLeft = rect.left + moveX;
        let newTop  = rect.top  + moveY;

        // Keep inside screen with margin
        newLeft = Math.max(KEEP_IN_MARGIN, Math.min(window.innerWidth - rect.width - KEEP_IN_MARGIN, newLeft));
        newTop  = Math.max(KEEP_IN_MARGIN, Math.min(window.innerHeight - rect.height - KEEP_IN_MARGIN, newTop));

        noBtn.style.left = newLeft + 'px';
        noBtn.style.top  = newTop + 'px';
        noBtn.style.transform = 'none'; // override centering
    }

    // ────────────────────────────────────────────────
    // Events
    // ────────────────────────────────────────────────
    document.addEventListener('mousemove', (e) => {
        moveButtonAway(e.clientX, e.clientY);
    });

    // Give it one extra kick when mouse actually touches it
    noBtn.addEventListener('mouseenter', () => {
        const rect = noBtn.getBoundingClientRect();
        moveButtonAway(rect.left + rect.width/2, rect.top + rect.height/2);
    });

    // Optional: tiny movement even when mouse is still (makes it feel alive)
    /*
    setInterval(() => {
        if (!isRunningAway) {
            moveButtonAway(lastMouseX, lastMouseY);
        }
    }, 1800);
    */

    yesBtn.addEventListener('click', () => {
        container.querySelector('.question, .buttons').style.display = 'none';
        successPage.style.display = 'block';
        document.body.style.background = 'linear-gradient(to bottom, #fff3f5, #ffebee)';
    });
</script>
